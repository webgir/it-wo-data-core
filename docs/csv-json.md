# Маппинг CSV → JSON

Этот документ описывает процесс преобразования нормализованных CSV-файлов в структурированный JSON-слой IWDC.

## 1. Входные данные

Скрипт `scripts/import-vitron-csv.mjs` читает два CSV-файла:

- `intermediate/csv/models.csv` — модели без длин
- `intermediate/csv/lengths.csv` — конкретные длины с параметрами

### Формат models.csv

Колонки:
- `series` — серия (например, "VK")
- `height` — высота (число)
- `width` — ширина (число)
- `tubes` — количество трубок (число)
- `type` — тип исполнения (буква: Г, К, В, П)
- `article_base` — артикул модели без длины (например, "ВК.55.160.2Г")
- `article_full` — полный артикул (равен `article_base` для моделей)

### Формат lengths.csv

Колонки:
- `article_full` — полный артикул с длиной (например, "ВК.55.160.600.2ТГ")
- `article_base` — артикул модели без длины
- `height`, `width`, `length`, `tubes`, `type` — параметры
- `weight` — вес (кг)
- `heat_output` — теплоотдача (Вт)
- `price_o`, `price_p`, `price_q`, `price_r`, `price_s` — цены в разных категориях

## 2. Процесс импорта

### Этап 1: Чтение CSV

Функция `readCSV(filePath)`:
- Читает файл в UTF-8
- Парсит строки с разделителем `;`
- Обрабатывает экранирование кавычек
- Возвращает массив объектов

### Этап 2: Построение JSON

#### Для моделей (`buildModelJSON`):

Преобразует CSV-строку в JSON-объект модели:

```json
{
  "series": "VK",
  "model_code": "ВК.55.160.2Г",
  "slug": "vk-55-160-2г",
  "path": "/vk/vk-55-160-2г",
  "material": "none",
  "lengths": ["vk-55-160-600-2г", "vk-55-160-700-2г"],
  "meta": {
    "version": "0.1.0",
    "updated": "2025-01-01T00:00:00.000Z",
    "hash": "abc123def456"
  }
}
```

#### Для длин (`buildLengthJSON`):

Преобразует CSV-строку в JSON-объект длины:

```json
{
  "series": "VK",
  "model_code": "ВК.55.160.2Г",
  "length": 600,
  "slug": "vk-55-160-600-2г",
  "path": "/vk/vk-55-160-2г/600",
  "thermal": {
    "watt": 125
  },
  "price": {
    "side": 9800,
    "bottom": 9800
  },
  "meta": {
    "version": "0.1.0",
    "updated": "2025-01-01T00:00:00.000Z",
    "hash": "def456ghi789"
  }
}
```

### Этап 3: Маппинг данных

**Маппинг полей:**

| CSV поле | JSON поле | Преобразование |
|----------|-----------|----------------|
| `article_base` | `model_code` | Без изменений |
| `article_full` | `slug` (для длин) | Транслитерация + lowercase |
| `heat_output` | `thermal.watt` | `parseFloat()` → `Math.round()` |
| `price_o` | `price.side` | `parseInt()` |
| `price_p` | `price.bottom` | `parseInt()` |
| `length` | `length` | `parseInt()` |

**Генерация метаданных:**

- `meta.version` — версия схемы (например, "0.1.0")
- `meta.updated` — ISO 8601 дата-время создания
- `meta.hash` — SHA-256 хеш содержимого (первые 16 символов)

**Связывание моделей и длин:**

- Модели группируются по `article_base`
- Для каждой модели собирается массив `lengths` из slug'ов связанных длин

### Этап 4: Валидация

Функция `validateBySchema(validator, data, schemaName)`:
- Валидирует каждый объект по соответствующей JSON Schema
- Использует `ajv` с поддержкой форматов
- Выводит детальные ошибки при несоответствии

### Этап 5: Запись файлов

Функция `writeOutput(filePath, data)`:
- Создаёт директории при необходимости
- Форматирует JSON с отступами (2 пробела)
- Записывает файлы в UTF-8

**Структура выходных файлов:**

- `data/json/models/{slug}.json` — один файл на модель
- `data/json/lengths/{slug}.json` — один файл на длину

## 3. Запуск импорта

```bash
node scripts/import-vitron-csv.mjs
```

Скрипт:
1. Загружает CSV-файлы
2. Строит JSON-объекты
3. Валидирует по схемам
4. Записывает файлы
5. Выводит статистику

## 4. Обработка ошибок

При ошибках импорта:
- Выводятся детальные сообщения об ошибках валидации
- Указывается файл и поле с проблемой
- Скрипт завершается с кодом выхода 1

Успешный импорт:
- Все файлы прошли валидацию
- JSON-файлы созданы в соответствующих директориях
- Скрипт завершается с кодом выхода 0

